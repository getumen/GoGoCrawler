// Code generated by MockGen. DO NOT EDIT.
// Source: request_repository.go

// Package repository is a generated GoMock package.
package repository

import (
	context "context"
	models "github.com/getumen/gogo_crawler/domains/models"
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
	time "time"
)

// MockRequestRepository is a mock of RequestRepository interface
type MockRequestRepository struct {
	ctrl     *gomock.Controller
	recorder *MockRequestRepositoryMockRecorder
}

// MockRequestRepositoryMockRecorder is the mock recorder for MockRequestRepository
type MockRequestRepositoryMockRecorder struct {
	mock *MockRequestRepository
}

// NewMockRequestRepository creates a new mock instance
func NewMockRequestRepository(ctrl *gomock.Controller) *MockRequestRepository {
	mock := &MockRequestRepository{ctrl: ctrl}
	mock.recorder = &MockRequestRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockRequestRepository) EXPECT() *MockRequestRepositoryMockRecorder {
	return m.recorder
}

// IsExist mocks base method
func (m *MockRequestRepository) IsExist(ctx context.Context, namespace, url string) (bool, error) {
	ret := m.ctrl.Call(m, "IsExist", ctx, namespace, url)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsExist indicates an expected call of IsExist
func (mr *MockRequestRepositoryMockRecorder) IsExist(ctx, namespace, url interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsExist", reflect.TypeOf((*MockRequestRepository)(nil).IsExist), ctx, namespace, url)
}

// FindAllByDomainAndBeforeTimeOrderByNextRequest mocks base method
func (m *MockRequestRepository) FindAllByDomainAndBeforeTimeOrderByNextRequest(ctx context.Context, namespace string, now time.Time, offset, limit int) ([]*models.Request, error) {
	ret := m.ctrl.Call(m, "FindAllByDomainAndBeforeTimeOrderByNextRequest", ctx, namespace, now, offset, limit)
	ret0, _ := ret[0].([]*models.Request)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindAllByDomainAndBeforeTimeOrderByNextRequest indicates an expected call of FindAllByDomainAndBeforeTimeOrderByNextRequest
func (mr *MockRequestRepositoryMockRecorder) FindAllByDomainAndBeforeTimeOrderByNextRequest(ctx, namespace, now, offset, limit interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAllByDomainAndBeforeTimeOrderByNextRequest", reflect.TypeOf((*MockRequestRepository)(nil).FindAllByDomainAndBeforeTimeOrderByNextRequest), ctx, namespace, now, offset, limit)
}

// FindByUrl mocks base method
func (m *MockRequestRepository) FindByUrl(ctx context.Context, namespace, url string) (*models.Request, error) {
	ret := m.ctrl.Call(m, "FindByUrl", ctx, namespace, url)
	ret0, _ := ret[0].(*models.Request)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByUrl indicates an expected call of FindByUrl
func (mr *MockRequestRepositoryMockRecorder) FindByUrl(ctx, namespace, url interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByUrl", reflect.TypeOf((*MockRequestRepository)(nil).FindByUrl), ctx, namespace, url)
}

// Save mocks base method
func (m *MockRequestRepository) Save(ctx context.Context, r *models.Request) error {
	ret := m.ctrl.Call(m, "Save", ctx, r)
	ret0, _ := ret[0].(error)
	return ret0
}

// Save indicates an expected call of Save
func (mr *MockRequestRepositoryMockRecorder) Save(ctx, r interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockRequestRepository)(nil).Save), ctx, r)
}
